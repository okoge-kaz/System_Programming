# Bash Script Syntax

## 基本

### シェバング

スクリプト行頭の#!で始まる行をシェバング（シェバン、シバンとも）といい、なんのプログラムで実行すべきかを指し示すことができる。   
シェルスクリプトの場合は、次のような形になる。

```
#!/bin/bash
```

```
#!/bin/sh
```

ちなみに、macOSのデフォルトシェルは多くの場合 zsh なので 
```
#!/bin/zsh
```
とするのがよい


ただし、sh とすると bash独自の記法が使用できなくなることがあるので注意
[参考](https://sechiro.hatenablog.com/entry/20120806/1344267619)

### 変数・文字列

#### 変数と代入   
任意の文字列を使った変数が作れる。参照時には`$`をつけるが、代入する際は`$`を使わない。代入は`=`を用いる。   
右辺式が文字列の時で、（途中に空白などがなく）式として成り立っていればクォーテーションしなくても代入が可能。   
`=`の前後に可読性目的で空白を入れてはいけない。言語的にエラーである。   
他のスクリプト言語のように`${VARIABLE}`といった形で`{}`で囲むことでき、明示的に文字列と区別させることが可能。

```shell
$ NAME='okoge-kaz'
$ id=20Bxxxxx

$ echo $NAME
$ echo "my id is ${id}"
```


#### 文字列連結
連結するには演算子などは必要なく、例のように繋げて記述すれば良い。繋げる文字列の間での空白は不要。

```shell
$ HOGE="hoge"
$ FUGA="fuga"
$ echo $HOGE$FUGA      # hogefuga
$ echo "hoge""fuga"    # hogefuga
```

#### ダブルクォーテーション
ダブルクォーテーションで囲んだ文字列では、式が展開される。
```shell
$ NUM=42
$ echo "THE ANSWER IS $NUM"           # THE ANSWER IS 42
$ echo "my HOSTNAME is `hostname`"    # my HOSTNAME is xxx
```

#### シングルクォーテーション
シングルクォーテーションマークで囲んだ文字列では、式は展開されない。   
`!`や`!!`などはBashはヒストリを参照する時の特殊コマンドになるので、これを文字列に埋め込むにはシングルクォーテーションで囲むなどしてエスケープする必要がある。

```shell
$ echo 'THE ANSWER IS $NUM'          # THE ANSWER IS $NUM (展開されない）
$ echo 'Hello!!'                     # ""だと、 !! が直前のコマンドに置き換わる
```

#### 位置パラメータ
スクリプト実行時に引数として渡された内容は、位置パラメータと呼ばれる特殊変数に保持される。これらはスクリプト中では、`$1`～`$9`で表わせる。  
10番目以降の位置パラメータは、`${10}`のように記述する。   
なお、位置パラメータは関数への引数を展開する場合にも使う。
  
```shell
$ piyopiyo.sh "hoge" "fuga" 3 4 5 6 7 8 9 ten eleven
# $1    => hoge
# ${10} => ten
```
**1-index**であることに注意

#### 位置パラメータ発展

位置パラメータを集合的に扱う場合は、`$*`, `$@`, `"$@"`を利用する。   
クォーテートしない`$@` は `$*` と同じだ。なので実質`$*`と`"$@"`を使い分ければ良い。

```sample.sh
echo '--- $* ---'; for P in $*; do echo $P; done
echo '--- $@ ---'; for P in $@; do echo $P; done        # $* と同じ
echo '--- "$@" ---'; for P in "$@"; do echo $P; done
```

```shell
$ ./sample.sh "1 2" "hoge fuga"
--- $* ---
1
2
hoge
fuga
--- $@ ---
1
2
hoge
fuga
--- "$@" ---
1 2
hoge fuga
```

### shellの変数展開

[詳細](https://qiita.com/bsdhack/items/597eb7daee4a8b3276ba)



## 1-unix のまとめ

`$ echo file.{src,dst}`   
`> file.src file.dst`

コマンドの結果を埋め込むには `` 以外にも `$(...)`も用いることができる。

記号`<`は標準入力，`>`は標準出力を，直後に指定したファイルにリダイレクトする． すでに`>`で指定したファイルが存在していると，内容は失われてしまうことに注意しよう． `>>` を使うと，出力ファイルを上書きするのではなく追記するようになる．


パターンが空白を含む場合は全体をクオートで括る必要があることに注意する必要がある
次の例のパターン^httpsにおける^は行頭を示しており，よってこれは「httpsで始まる行」という意味になる．
```shell
> grep '^https' services.txt          # 文字列 https から始まる行のみ表示
https       443/tcp
https       443/udp
https       443/sctp
```

grepは様々なオプション引数をとる． たとえば，-rをつけると，ディレクトリを指定したときにその内部のファイルを探しにいくようになる． また，-vをつけると，マッチ「しない」行のみを表示するようになる．

uniqは連続した同一行しか削除しない．

コマンド群をかっこ( ... )で括ると，該当部分を実行するシェルが別途起動する． これをサブシェルという． かっこで括った部分をひとつのプロセスとして扱うことができるため，かっこでくくった部分に対してパイプでデータを流したり，リダイレクトでファイルに結果を出力することができる．


普通にプロセスを実行することを，「ユーザーの目の前で実行される」という意味で「フォアグラウンド実行」という． 一方，常に実行させておきたいプロセスや，時間のかかる計算プログラムなどは，ユーザに見えない「裏側」で実行させ，その間ユーザは別の仕事もできるようにすれば便利である． この「裏側」での実行を「バックグラウンド実行」という． バックグラウンドで実行するには，以下のようにコマンドの後に&をつける．

`> sleep 1000 &`

## 参考資料

[Qitta: Bash Script Syntax](https://qiita.com/Ping/items/57fd75465dfada76e633)
